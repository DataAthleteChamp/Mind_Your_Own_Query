package jpamb.sqli;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

/**
 * Database helper for SQL injection test cases.
 *
 * This class provides access to a real java.sql.Statement object
 * so that test cases use actual JDBC API signatures that can be
 * detected by taint analysis tools.
 *
 * For testing purposes, the statement operations are stubbed to
 * avoid requiring an actual database connection.
 */
public class DatabaseHelper {

    private static Statement mockStatement = new MockStatement();

    /**
     * Get a Statement object for executing SQL queries.
     * In production, this would come from a real connection.
     * For testing, we use a mock that prints queries.
     */
    public static Statement getStatement() {
        return mockStatement;
    }

    /**
     * Execute a query using a Statement.
     * This is a convenience method that uses the real JDBC API.
     */
    public static void execute(String query) throws SQLException {
        getStatement().executeQuery(query);
    }

    /**
     * Mock Statement implementation for testing.
     * Implements just enough to compile and run.
     */
    private static class MockStatement implements Statement {
        @Override
        public ResultSet executeQuery(String sql) throws SQLException {
            System.out.println("Executing SQL: " + sql);
            return null;
        }

        @Override
        public int executeUpdate(String sql) throws SQLException {
            System.out.println("Executing SQL update: " + sql);
            return 0;
        }

        @Override
        public boolean execute(String sql) throws SQLException {
            System.out.println("Executing SQL: " + sql);
            return false;
        }

        // Stub implementations for other Statement methods
        @Override public void close() {}
        @Override public int getMaxFieldSize() { return 0; }
        @Override public void setMaxFieldSize(int max) {}
        @Override public int getMaxRows() { return 0; }
        @Override public void setMaxRows(int max) {}
        @Override public void setEscapeProcessing(boolean enable) {}
        @Override public int getQueryTimeout() { return 0; }
        @Override public void setQueryTimeout(int seconds) {}
        @Override public void cancel() {}
        @Override public java.sql.SQLWarning getWarnings() { return null; }
        @Override public void clearWarnings() {}
        @Override public void setCursorName(String name) {}
        @Override public ResultSet getResultSet() { return null; }
        @Override public int getUpdateCount() { return 0; }
        @Override public boolean getMoreResults() { return false; }
        @Override public void setFetchDirection(int direction) {}
        @Override public int getFetchDirection() { return 0; }
        @Override public void setFetchSize(int rows) {}
        @Override public int getFetchSize() { return 0; }
        @Override public int getResultSetConcurrency() { return 0; }
        @Override public int getResultSetType() { return 0; }
        @Override public void addBatch(String sql) {}
        @Override public void clearBatch() {}
        @Override public int[] executeBatch() { return new int[0]; }
        @Override public Connection getConnection() { return null; }
        @Override public boolean getMoreResults(int current) { return false; }
        @Override public ResultSet getGeneratedKeys() { return null; }
        @Override public int executeUpdate(String sql, int autoGeneratedKeys) { return 0; }
        @Override public int executeUpdate(String sql, int[] columnIndexes) { return 0; }
        @Override public int executeUpdate(String sql, String[] columnNames) { return 0; }
        @Override public boolean execute(String sql, int autoGeneratedKeys) { return false; }
        @Override public boolean execute(String sql, int[] columnIndexes) { return false; }
        @Override public boolean execute(String sql, String[] columnNames) { return false; }
        @Override public int getResultSetHoldability() { return 0; }
        @Override public boolean isClosed() { return false; }
        @Override public void setPoolable(boolean poolable) {}
        @Override public boolean isPoolable() { return false; }
        @Override public void closeOnCompletion() {}
        @Override public boolean isCloseOnCompletion() { return false; }
        @Override public <T> T unwrap(Class<T> iface) { return null; }
        @Override public boolean isWrapperFor(Class<?> iface) { return false; }
    }
}
